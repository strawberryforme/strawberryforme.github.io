(window.webpackJsonp=window.webpackJsonp||[]).push([[47],{448:function(e,t,n){"use strict";n.r(t);var o=n(2),r=Object(o.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("blockquote",[t("p",[e._v("Object是引用类型最重要的数据结构。")])]),e._v(" "),t("p",[e._v("1、对象分类：\n内置对象：\n构造函数的属性方法。\n构造函数的原型对象属性和方法。\n实例对象的属性和方法。\n自定义对象：")]),e._v(" "),t("p",[e._v("2、原型和原型链\n对象在找属性和方法是会找原型链。\n对象的作用域不会找原型链哦。会找作用域。")]),e._v(" "),t("p",[e._v("3、创建一个对象。就是在实现继承。通过原型链的方式实现继承。\njs 中在 new 的时候发生了什么 。 关于 new，判断以下代码输出\n构造函数对象属性有多种。\n对象有私有属性和共有属性。\nObject.propertyIsEnumerable()")]),e._v(" "),t("p",[e._v("从一个对象上删除一个属性：须使用 delete 操作符\n4、继承的多种方式。\n实现一个 inherits 函数进行继承")]),e._v(" "),t("p",[e._v("2、对象：\n1、属性\nObject.prototype.consturee\n对象在找属性和方法是会找原型链。\n对象的作用域不会找原型链哦。会找作用域。\nObject.prototype."),t("strong",[e._v("proto")]),e._v(" 建议使用Object.getPrototypeOf()和Object.setPrototypeOf。\nObject.getPrototypeOf(obj1) ==obj1."),t("strong",[e._v("proto")]),e._v("\n也不鼓励使用它。因为它从来没有被包括在 EcmaScript 语言规范中，但是现代浏览器都实现了它\n2、静态方法\nObject.assign() Object.create() 使用指定的原型对象和属性创建一个新对象。\n通过复制一个或多个对象来创建一个新的对象。\nObject.getPrototypeOf()\n返回指定对象的原型对象。 替换调__proto__\nObject.setPrototypeOf() //不建议使用 setPrototypeOf 来代替 extends。\n设置对象的原型（即内部 [[Prototype]] 属性）。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("    关于属性的：  \n        添加修改属性：\n            Object.defineProperty() Object.defineProperties()\n\n        查找属性描述符：\n            Object.getOwnPropertyDescriptor()\n\n        查找属性名（对象所有的可枚举或不可枚举的属性名。），返回一个数组：\n            Object.getOwnPropertyNames()\n        \n        返回一个包含所有给定对象自身可枚举属性名称的数组：\n            Object.keys() Object.values() ['value'] Object.entries()\n\n        查找symbol属性名和属性值：\n            Object.getOwnPropertySymbols()\n\n        永远不能再添加新的属性。永远不能删除更改新属性。判断对象是否已经密封。\n            Object.preventExtensions() Object.isExtensible()\n            Object.freeze() Object.isFrozen()\n            Object.isSealed() Object.seal()\n        判断属性值是否相等：\n            Object.is()\n            比较两个值是否相同。所有 NaN 值都相等（这与==和===不同）。\n            不会强制转换两边的值。-0 和 +0 视为不相等，而将 NaN和0/0 视为不相等。\n3、实例方法：\n    Object.prototype.hasOwnProperty()\n    自身是否有属性：返回一个布尔值,对象自身属性中是否具有指定的属性，该方法并不会查找原型链上继承来的属性。\n\n    Object.prototype.propertyIsEnumerable()\n    自身属性是否可以枚举。返回一个布尔值，用于表示内部属性 ECMAScript [[Enumerable]] attribute 是否被设置。\n    表示指定的属性是否可枚举。\n\n    Object.prototype.isPrototypeOf()\n        返回一个布尔值，用于表示该方法所调用的对象是否在指定对象的原型链中。\n\n    Object.prototype.toString() Object.prototype.toLocaleString()\n    返回一个代表该对象的字符串。 \"[object Type]\" [object Null] 和 [object Undefined]。\n    要将基本的 Object.prototype.toString() 用于重写的对象（或者在 null 或 undefined 上调用它），你需要在它上面调用 Function.prototype.call() \n    或者 Function.prototype.apply()，将要检查的对象作为第一个参数传递（称为 thisArg）。\n\n    Object.prototype.valueOf()\n    返回指定对象的原始值。\n")])])]),t("p",[e._v("如何遍历一个对象  （Object.keys 与 Object.getOwnPropertyNames() 有何区别）\nObject.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。(没有不可枚举的)\nObject.getOwnPropertyNames(obj) Object.getOwnPropertySymbols(obj)\n（不含Symbol属性，但是包括不可枚举属性）。包含对象自身的所有Symbol属性。\nReflect.ownKeys(obj)\n返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("终极大哥：for in 对象+原型链 对象自身的和继承的可枚举属性（不含Symbol属性）。\n")])])]),t("p",[e._v("在 JS 中如何监听 Object 某个属性值的变化\n如何把对象转化为 key/value 的二维数组\nObject.is 与 全等运算符(===)有何区别")]),e._v(" "),t("p",[e._v("如何实现一个深拷贝 (cloneDeep)\nJS 如何检测到对象中有循环引用")]),e._v(" "),t("p",[e._v("简述 Object.defineProperty")]),e._v(" "),t("p",[e._v("如何找到当前页面出现次数最多的HTML标签\n解构赋值一个数组，a 取第一项默认值为 3，c取剩下的值组成数组 解构赋值以下对象，他们的值是多少")])])}),[],!1,null,null,null);t.default=r.exports}}]);