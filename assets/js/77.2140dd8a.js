(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{477:function(n,e,t){"use strict";t.r(e);var i=t(2),u=Object(i.a)({},(function(){var n=this._self._c;return n("ContentSlotsDistributor",{attrs:{"slot-key":this.$parent.slotKey}},[n("div",{staticClass:"language-text extra-class"},[n("pre",{pre:!0,attrs:{class:"language-text"}},[n("code",[this._v("Vue全局\n1.版本：\n    \n    Vue.version\n\n2.模板字符串编译成 render函数。\n    \n    Vue.compile( template )。只在完整版时可用。\n\n3、 Vue.set：创建全局的\n\n    Vue.delete\n    Vue.observable\n\n4.操作更新后的DOM：\n\n    Vue.nextTick\n    问题：操作数据改变了dom。然后对改变后的DOM进行操作。\n    todo.ref = true //Vue第一次解析数据的时候，发现数据改变了dom，因为Vue是异步更新DOM，所有不会生产新DOM。\n    this.$ref.inputTitle.focus() //然后同步对改变后的DOM进行操作。就会发现没有新的DOM\n\n    解决：\n        问题：因为同步代码在DOM还没有更新时候操作。\n        方法：把回调函数放在DOM更新完以后。\n        1.定时器：加入定时器。setTimeout((xxx)=>{},200)\n        2.this.nextTick： this.$nextTick( function(xxx){})\n    \n    nextTick\n        1.使用场景：（Vue生命周期的created()钩子函数进行的DOM操作的时候需要要放在Vue.nextTick()的回调函数中。）\n        2.原理：\n        先定义了一个callbacks 存放所有的nextTick里的回调函数\n        然后判断一下当前的浏览器内核是否支持 Promise，如果支持，就用Promise来触发回调函数\n        如果不支持Promise再看看是否支持MutationObserver，是一个可以监听DOM结构变化的接口，观察文本节点发生变化时，触发执行所有回调函数。\n        如果以上都不支持就只能用setTimeout来完成异步执行了。\n        （promise -> mutationObserver -> setImmediate -> setTimeout）\n        （当调用nextTick方法时会传入两个参数，回调函数和执行回调函数的上下文环境，如果没有提供回调函数，那么将返回promise对象。首先将拿到的回调函数存放到数组中，判断是否正在执行回调函数，如果当前没有在pending的时候，就会执行timeFunc，多次执行nextTick只会执行一次timerFunc，timeFunc其实就是执行异步的方法，在timeFunc方法中选择一个异步方法（首先判断是否支持promise，如果支持就将flushCallbacks放在promise中异步执行，并且标记使用微任务。如果不支持promise就看是否支持MutationObserver方法，如果支持就new了一个MutationObserver类，创建一个文本节点进行监听，当数据发生变化了就会异步执行flushCallbacks方法。如果以上两个都不支持就看是否支持setImmediate方法，如果支持setImmediate 就去异步执行flushCallbacks方法。如果以上三种方法都不支持，就使用setTimeout），然后异步去执行flushCallbacks方法，flushCallbacks中就是将传递的函数依次执行。\n        vue如何检测到DOM更新完毕呢？\n        能监听到DOM改动的API：MutationObserver\n\n5、Vue.use：增加插件。\n\n    场景：用于增强vue\n    本质：包含install方法对象。install第一个参数是vue。第二个是传递\n    \n    语法：\n        1.定义插件：\n        Vue会自动install\n        export defalut{ install(Vue){ \n        //全局过滤器。Vue.filter('')  \n        //定义混入 Vue.mixin({})\n        //Vue原型添加一个方法。vm和vc都可以用\n        }}\n        2.引入插件\n            import plugins from './plugins' \n        3.使用插件\n        Vue.use(plugins)    \n\n增加的资源、\n1、组件。\n2、过滤。\n3、指令。\n\n    1、Vue.Componet\n    2、Vue.filter\n\n    过滤器：\n    定义：\n        对显示的数据特定格式化。（只是用于简单逻辑）\n        对现实的数据进行特定的格式化。\n        （只适合简单的逻辑处理，复杂的还是用计算属性和方法，一般用于time）\n    语法：\n        1.全局注册过滤器：Vue.filter(name,callback) \n        2.局部注册过滤器: new Vue({filter:{}})\n        3.静态使用过滤器：{{ 需要传入的参数 || 过滤器名字}} {{ 需要传入的参数 || 过滤器名字 ||过滤器名字}}\n        4.动态使用过滤器：v-bind:属性={{xxx||过滤器名字}}\n    语法：\n        1.注册过滤器：\n        Vue.filter()\n        Vue.filter('mySlice',function(value){\n        return value.slice(0,4)})\n        \n        new Vue(filter:{})\n        filter:{\n            timeFomater(value,str='YYYY'){\n                return day.js(value).format()\n            }\n        }\n    \n        2.使用过滤器\n        \n            {{ data数据 |过滤器名字}}data给后面的函数，返回给数据里面\n            v-bind:属性=\"xxx|过滤器名字\"\n            过滤器实现。 {{ data.time | timeFomater}}\n        \n            过滤器传参。 {{ data.time | timeFomater('YYYY_MM_DD')}}\n            过滤器串联： {{ data.time | timeFomater('YYYY_MM_DD') | mySlice()}} \n            |前面都是后面的参数哦。函数里面还可以有参数。\n    \n        3.备注：\n            1.过滤器可以接受额外参数。多个过滤器串联\n            2.没有改变原本的数据，产生新的对应数据。\n    3、vue.directive\n\n6、组合：\n\n    parent\n    mixins\n    extends\n    provide.inject\n    1、Vue.mixin\n        场景：把多个组件共有的数据，方法，构造函数 提取成一个混入对象。\n        语法：\n            1.创建：export const mixin1 = { data(){},methods:{},mouted:{}}\n            2.导入：import {mixin1,mixin2} from '../mixin'\n            3.全局使用：全局混入Vue.mixin(xxx)。\n            4.局部混入：minins:['xxx']，\n        说明：\n            1.如果实例vue和混合有data 和methods，以组件内为主。\n            2.如果是生命周期钩子，则都需要使用。\n\n")])])])])}),[],!1,null,null,null);e.default=u.exports}}]);