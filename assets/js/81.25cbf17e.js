(window.webpackJsonp=window.webpackJsonp||[]).push([[81],{481:function(n,e,t){"use strict";t.r(e);var a=t(2),s=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"js"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[n._v("#")]),n._v(" JS")]),n._v(" "),e("p",[n._v("1.data")]),n._v(" "),e("p",[n._v("2.prop")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('场景：子组件接受 外部组件传入的值\n1.传递数据 \n    子组件+ 属性名 + 值。(属性名不能是key，ref)\n    子组件+ v-bind + 属性名 + 变量。(v-bind: ""引号里面的值，表达式执行的结果。传过去。)\n\n    1.传入一个字符串：\n    <子组件 sex="man">标签属性. 静态传入一个字符串。如果传入18，那么sex=18.\n    <子组件 :sex="user.sex">标签属性.动态赋予一个变量的值。变量的值会变为字符串。 \n    \n    2.传入一个数字：\n    <blog-post :likes="42"></blog-post> //即便 `42` 是静态的，我们仍然需要 `v-bind` \n    <blog-post :likes="post.likes"></blog-post> \n\n    3.传入一个布尔值：\n    <blog-post :is-published="false"></blog-post>\n    <blog-post :is-published="post.isPublished"></blog-post>\n\n    4.传递数组：\n    <blog-post :comment-ids="[234, 266, 273]"></blog-post>\n    <blog-post :comment-ids="post.commentIds"></blog-post>\n\n    5.传入对象：\n    <blog-post :author="{name: \'Veronica\',company: \'Veridian Dynamics\'}"></blog-post>\n    <blog-post :author="post.author"></blog-post>\n    传入对象所有property：\n    <blog-post v-bind="post"></blog-post>\n    <blog-post :id="post.id" :title="post.title"></blog-post>\n    \n    6.也可以使其他构造函数。\n2.接受数据 \n    1.只接受：prop:[\'属性名\']\n    2.接收且显示类型:prop:{ name:String}\n    3.限制类型，限制必要性，默认值\n     name:{type:String,required:true,default:\'老王\'}\n    \n3.使用数据\n    只要在prop里面的数据，都会在vm身上，所有可以读取，但是不能改变。\n    如果传入了数据，必须接收数据，否则会失败。\n')])])]),e("p",[n._v("1.methods")]),n._v(" "),e("p",[n._v("2.computed")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("场景：1个数据由多个数据决定。则比如购物车。\n原理：底层借助了Object.defineproperty方法提供的getter和setter\n优点：1、将属性值计算专门存放。代码从模板分离。2、如果没有发生改变，会从缓存中读取。\n缺点：计算属性靠返回值返回，所以不能处理异步方法，\n\n\n定义：通过计算而得来的动态属性, 该计算结果会被缓存起来。\n调用：computed内部的函数在调用时不加()。"+n._s(n.fullName)+" ,in\" \"\n触发：1、模板第一次渲染的时候。2、关联属性修改的时候。\n\n写法1：必须要return。fullName:{get() {if(){return } else return}} 。\n写法2：关闭缓存，默认为true 。cache:false。return Data.now() + this.text\n写法3：如果自己有修改，必须set。fullName:{get() {return},set(value){}//} this.didiFamily = 'John Doe'。\n写法1简写： fullName{get(){}}。allname:这个就是fullName:get(){},===function(){}。allname(){}//简写。是个属性不是函数哦。\n语法限制：必须是data和prop没有出现过的属性，data属性从而触发computed中的函数，形成死循环了。函数必须要有return。\n")])])]),e("p",[n._v("3.watch")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("场景：一个数据影响多个数据.当需要在数据变化时执行异步或开销较大的操作时.\n原理： watch深层监听数据的变化。\n优点： 相当于一个观察者模式。监听数据改变，进行同步或者异步操作。\n缺点： watch没有缓存。\n\n定义： watch是一个key，value形式。可以监听data，prop，computed，路由\n调用： 1、数据第一次加载不会调用，数据改变时候，会被动调用。2、如果数据第一次加载需要调用，用immdeate。\n属性和函数： 1.immter。2.deep。3.handler(写其他函数没有用)。\n\n写法1：Vue完整写法，1函数2属性：watch:{data1{ handlder(new,old){}; immediate:true;deep:true}}\n写法2：Vue只写1函数的时候，简写watch:{data1(new，old){}}\n写法3：实例写法：vm.$watch('data1',{handler(){};immediate:true;deep:true})\n写法4：实例写法，简写：vm.$watch('data1',function(new,old){})\n\n语法限制：\n1、检测的可以是data，可以是props，可以是computed.\n2、深度监听，不能直接写number.a不能成为key因为是字符串\n3、Vue里面的函数不要用箭头函数。this需要绑定Vue实例的。\n")])])]),e("h2",{attrs:{id:"html"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#html"}},[n._v("#")]),n._v(" HTML")]),n._v(" "),e("p",[n._v("1.插值语法和指令\n为什么把治理放在模板里面，方便数据的渲染。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('1、条件渲染v-if:\n    写法：v-if="表达式"，v-else-if="",v-else。\n    原理：不展示DOM元素直接移除。使用v-if的时候，元素可能无法获取。\n    适用于：切换频率低的场景。\n    注意：v-if可以单数使用。也可以和v-else-if，v-else共同使用时不能有断开。\n    配合：可以和template配合使用。<template v-if=""></template>\n2、条件渲染v-show:\n    写法：v-show="表达式"\n    原理:通过改变display:none和displaye:block改变        \n    适用于:切换频率高的场景。\n    特点：不展示DOM元素未被移除，仅仅使用样式隐藏。元素都可以获取。\n3、列表渲染：v-for\n    写法：\n    \n    1、数组、数组对象\n    v-for="item in items" \n    v-for="(item, index) in items"\n\n    2、对象\n    v-for="value in object"\n    v-for="(value, name) in object"\n    v-for="(value, name, index) in object"\n\n    //ES1:for in 适用遍历 对象，且它是无序遍历，不按照顺序来，原型上的属性或方法也会被遍历出来 ，\n    //ES6:for of适用遍历 数组、数组对象、字符串、map、set等拥有迭代器对象的集合，有序遍历，但是不能遍历对象，因为没有迭代器对象，与forEach() 不同的是\n    //for in是遍历（object）键名，for of是遍历（array）键值\n    //for in对于数组的时候是序列号。 for of不能不可以遍历普通对象。\n    \n    3、key原理\n\n    一、有key和无key对比\n    需要知道的知识点：\n    1、\n\n    有key：\n\n    数据的渲染更新：初始数据-》虚拟DOM（+diff算法。）-》真实dom。\n    \n    两次虚拟DOM有一个DIFF算法。\n    (1)时虚拟DOM中未找到与新虚拟DOM相同的key\n    创建新的真实DOM，随后渲染到到页面。\n    （2）找到了，\n    1、虚拟DOM内容没有变，直接用。\n    2、虚拟DOM内容变了，生产的新的真实dom值。\n     \n    没有key：默认是有key。key=index。就地复用，\n    \n    二、实例。\n    如果key=index\n    li key = 0  li key=0\n    li key = 1  li key = 1\n    li key = 2  li key =2\n                li key = 3\n    虚拟dom的文字节点：是不一样的。那么就更换。\n    虚拟dom的input输入框节点：是一样的。 那么就不更换。\n    更换后的 +++ 遇见了 没有更换的 节点框拉胯了。\n    \n    key=id\n    key==001 ,key=004(重新生成新的。)\n    key=002,  key =001,\n    key=003,   key=002,\n                key =003\n    \n    明显看出，当有渲染数据文本节点+input节点的时候。\n    1、对于数据进行：逆序添加，逆序删除 破坏操作。\n    会产生没有必要的真实dom更新===》页面效果没有问题，但是效率低。\n    可以提高效率，复用其他的。\n\n    2、如果结构中有输入类的dom：\n    会产生错误dom更新=》界面有问题。\n    防止 文本 和 input错位。\n    \n    三、总结：\n    1、为什么要有key。key作用：\n    1、key的作用主要是为了高效的更新虚拟DOM。且不产生错误的DOM更新。\n    2、另外vue中在使用相同标签名元素的过渡切换时，也会使用到key属性，其目的也是为了让vue可以区分它们，否则vue只会替换其内部属性而不会触发过渡效果。\n\n    2、开发使用key：\n    1、唯一表示。id，身份证号，手机号。\n    2、如果不存在数据逆序添加，逆序虚拟删除破坏操作。用index为key是可以的。\n\n    4、列表过滤\n    watch:{key(new,old){  }}\n\n    5、列表排序：\n        先过滤，在排序。\n\n\n1、v-model\n    若：input type="text，password,number"。收集value=用户输入的value。\n    若 input type="radio" 则用户v-model收集的value值就是点击的，但是需要配置value.否则就是空。\n    若 input type = checkbox \n        1.没有配置inputvalue属性。收集的checkout的布尔值。（未勾选和勾选的，是布尔值）\n        2.配置inputvalue属性： \n            1。v-model非数组。那么收集的checked。（未勾选和勾选的，是布尔值）\n            2.v-model数组。收集的组成数组。\n    备注：v-model三个修饰符\n        v-model.lazy:失去焦点\n        v-model.number:转字符串。\n        v-model.trim:过滤\n')])])]),e("p",[n._v("2.自定义指令")]),n._v(" "),e("h2",{attrs:{id:"css"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#css"}},[n._v("#")]),n._v(" CSS")]),n._v(" "),e("p",[n._v("vue为了不操作真实dom，除了处理了JS函数。还将css属性动态进行动态绑定。")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v('一、静态绑定属性: class=""。style="font:size;"\n二、动态绑定属性:\n1、class写法：:class=""。里面可以是字符串，数组，对象\n    字符串：一般使用于1个类名。\n    数组： 适用于绑定多个样式，个数不确定，名字不确定。多选。\n    对象： 使用于绑定多个样式，个数确定，名字确定。适用于切换多选1。对象的value都是true，false。\n2、style写法:\n    对象：:style="{fontSize:xxx}"xxx是动态的值。\n    数组：:style="[a,b]" 其中a，b是样式对象。\n\n三、scope\n    原理：scope会给 class+特定索引。\n    语法：\n    div class=\n        h class=\n    \n    1.style lang ="css" scope 里面.class{}\n    \n    2.style lang ="less" scope\n\n四、\n    动画：<transition name=todo></transition>\n    \n    过度： transform\n        v-enter\n        v-enter-active v-enter-to v-leave v-leave-active v-leave-to')])])])])}),[],!1,null,null,null);e.default=s.exports}}]);