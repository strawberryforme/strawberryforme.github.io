(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{482:function(e,t,n){"use strict";n.r(t);var s=n(2),o=Object(s.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("1、v-for:key\nkey使用\nkey原理")]),e._v(" "),t("p",[e._v("2、ref:\nid的替代者\nref使用\nref原理")]),e._v(" "),t("p",[e._v("3、is\nis原理")]),e._v(" "),t("p",[e._v("4、slot (传HTML方式)")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('背景：如果组价A想给子组件B，传入HTML、图片等值应该怎么办呢。\n实质：也一种通信间的方式。父给子传HTML。（传入数据用prop，方法用prop）\n方法：A给B传入数据。但是B里面使用slot方法占坑。\n\n默认插槽：\n    概念：A引用B用全部，并且传入值。B里面使用 <slot>占坑。（把里面的坑slot放在, 用的时候填上。）\n    A里面：<B>HTML结构</B>\n    B里面：<slot>默认</slot>\n具名插槽：\n    概念：坑取上名字，用的时候填上。\n    A里面：<B> <img slot=center /> HTML结构</B>\n    A里面：<B> <template v-slot:center> HTML结构</template></B> (tempalte不生产dom元素，且可以包裹div。)\n    B里面:<slot name = center><slot name=footer>\n作用域插槽：\n    子元素想给父亲传入数据，父亲决定儿子数据的结构。\n    A里面：<B> <template scope="game">HTML数据</template> </B> (解构赋值：scope="{game}")\n    A里面：<B> <template slot-scope="game">HTML数据</template> </B> (解构赋值：scope="{game}")\n    B里面：<slot :game="data"></slot>\n')])])])])}),[],!1,null,null,null);t.default=o.exports}}]);