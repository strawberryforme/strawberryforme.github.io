(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{468:function(t,a,n){"use strict";n.r(a);var s=n(2),e=Object(s.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"_1、输入url后发生一系列的。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、输入url后发生一系列的。"}},[t._v("#")]),t._v(" 1、输入URL后发生一系列的。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1、解析URL:浏览器进程。解析URL。https。网站名。资源链接。\n2、包装报文：应用层-网络层-数据链路层。包装报文。\n3、找到IP: DNS解析域名。  浏览器缓存。 本地缓存。 路由DNS缓存。 DNS寻址。\n4、三次握手判断服务器是否可以正常通信。发送请求。服务器处理并返回请求。客户端拿到报文，响应数据。\n5、HTML->解析标签->DOM树。CSS->渲染。遇到script脚本会加载。 render树。 layout布局。paint。\n")])])]),a("h3",{attrs:{id:"_1-1、解析html"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-1、解析html"}},[t._v("#")]),t._v(" 1.1、解析html")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("DOM树（不必解析完）+CSS结构（必须解析完）-》才开始JS脚本—》阻塞DOM解析\n1、JS会阻塞DOM生产。\n2、样式文件会阻塞js执行。\n解析是由。Byte01 01 01代码。->通过编码规则变为字符串-》Token（打标签）-》Node —》 DOM\n")])])]),a("h3",{attrs:{id:"_1-2、scirpt放在head和body区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-2、scirpt放在head和body区别"}},[t._v("#")]),t._v(" 1.2、scirpt放在head和body区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1、渲染html是从上倒下。遇到js会停止html和css渲染。去开启js引擎下载文件。\n2、放在顶部会阻塞。放在底部不会阻塞。\n")])])]),a("h3",{attrs:{id:"_1-3、script标签async"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-3、script标签async"}},[t._v("#")]),t._v(" 1.3、script标签async")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("async:异步加载，执行的时间是下载完立刻执行，谁先下载完执行，执行时间在load事件之前。（仍有可能阻止解析HTML，）\n应用在不依赖脚本的，不关心页面中的DOM元素（文档是否解析完毕）。如：百度统计、Google\ndefer：异步下载文件。defer会在文档渲染完后执行，按照顺序执行，domconetloeaded事件调用前执行。\n比如:脚本代码依赖于页面中的DOM元素（文档是否解析完毕).评论框、代码语法高亮 、polyfill.js.\n")])])]),a("h3",{attrs:{id:"_1-4、css的link和import区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-4、css的link和import区别"}},[t._v("#")]),t._v(" 1.4、CSS的link和import区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("link：不会阻塞。\nimport：会阻塞。\n")])])]),a("h3",{attrs:{id:"_1-5、回流和重绘"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-5、回流和重绘"}},[t._v("#")]),t._v(" 1.5、回流和重绘")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1、回流 \n当增加或删除dom节点，或者给元素修改宽高时。\n会改变页面布局。那么就会重新构造dom树然后再次进行渲染，这就是回流。\n减少重排元素。position为absolute和fixed。\n2、重绘 \n重新绘画（页面的重新渲染），对页面进行操作，\n如：更换颜色、更换背景，会重新渲染页面，这就是重绘。\n")])])]),a("h3",{attrs:{id:"_1-6、domcontentload-和-load区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-6、domcontentload-和-load区别"}},[t._v("#")]),t._v(" 1.6、DOMcontentLoad 和 Load区别")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("DOMcontentLoad：HTML文档（CSS、JS）被加载以及解析完成之后触发（即 HTML->DOM的过程完成 ）\nLoad：load需要在页面的图片、视频等加载完后被触发\n")])])]),a("h2",{attrs:{id:"_2-关于白屏和首屏的问题。"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-关于白屏和首屏的问题。"}},[t._v("#")]),t._v(" 2 关于白屏和首屏的问题。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1、白屏（显示第一个字符或者元素的时间）: \n之前的方法： head 末尾插入一段获取时间戳的代码，然后用这个时间戳减去开始接收数据的那个时间戳。\nHTML5推出：performance 包括了五个属性，其中 timing 是我们需要重点关注的。\n现在的方法：timingInfo.responseStart - timingInfo.fetchStart;\n2、首屏（首页显示完成）: 首屏内容渲染结束 - 开始请求的时间点\n之前的方法：统计首屏内图片完成加载的时间。加载最慢的图片的时间点 - performance.timing.navigationStart;\n现在的方法：timingInfo.domComplete - timingInfo.fetchStart;\n3、对比：首屏时间会比白屏时间更精确。大型的复杂页面，你会发现由于需要处理更多复杂的元素，白屏时间和首屏时间相隔比较远。\n首屏时间 = 白屏时间 + 首屏（开始渲染到）完全渲染完成的时间\n4、Vue和React等前端框盛行, 导致Performance无法准确的监控到页面的首屏时间。\n5、白屏错误页的监控的：\n排查网络。js 是否下载成功 cdn 是否生效。\n做 js 错误上报。分析是否存在代码缺陷。\n排查兼容性。大部分原因是因为低端机型/浏览器低版本 polyfill 的问题导致报错。\nError Boundry 避免整页崩溃。限制在组件级别。\n")])])]),a("h2",{attrs:{id:"_3、性能优化"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3、性能优化"}},[t._v("#")]),t._v(" 3、性能优化")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("1、URL解析。no\n2、包装报文。no\n3、找到IP：DNS解析。\nDNS 预解析\n使用 meta 标签   使用 link 标签\n4、HTTP请求。用HTTP2。 服务器解析服务器渲染 (SSR)。\n减少 HTTP 请求数量，减少 HTTP 请求大小。\n静态资源使用 内容分发网络（CDN）\n解决用户与服务器物理距离对响应时间的影响，在多个位置部署服务器，让用户离服务器更近，从而缩短请求时间。\n服务器优化\n在服务端将请求的所有资源生成 HTML，客户端收到后可以直接渲染。\n更快的内容到达时间 (time-to-content)。更好的 SEO.\n\n5、\n使用 Defer 加载 JS。\n尽量将 CSS 放文件头部，JS 文件放在底部，给 script 标签加上 defer 属性。\n资源缓存，不重复加载相同的资源\n\n重复依赖包处理，可以采用 pnpm 减少第三方依赖的体积\n采用 code splitting，减少首次请求体积压缩文件；按需加载代码，减少冗余代码\n图片优化（雪碧图、图片懒加载、CSS 图片懒加载）\n利用 webpack 的 contenthash 缓存\n")])])])])}),[],!1,null,null,null);a.default=e.exports}}]);