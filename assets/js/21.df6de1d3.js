(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{427:function(n,e,t){"use strict";t.r(e);var a=t(2),l=Object(a.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("blockquote",[e("p",[n._v("理论：1、流式布局  2、定位。3、浮动  4、flex 5、Grid 6、溢出 7、BFC")])]),n._v(" "),e("blockquote",[e("p",[n._v("实战：1、盒子移动。2、垂直居中。3、两列布局。4、三列布局。5、等分布局 6、全屏布局")])]),n._v(" "),e("h2",{attrs:{id:"part1、流式布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part1、流式布局"}},[n._v("#")]),n._v(" Part1、流式布局")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("从上到下布局。\n借助margin来进行移动。\n")])])]),e("h2",{attrs:{id:"part2、定位"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part2、定位"}},[n._v("#")]),n._v(" Part2、定位")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("static。的元素不会以任何特殊方式定位；它始终根据页面的正常流进行定位：。\nrelative：\n不会失去文档中位置。\n相对定位元素的定位是相对它自己的正常位置的定位。\n相对于最近的父元素。根元素。\n相对定位是相对于元素在文档中的初始位置；因此，移动元素会导致它覆盖其它框。\n\nabsolute：\n导致元素脱离文档流.绝对定位的元素相对于 static 定位以外的第一个父元素进行定位。(父元素具有position:relative/absolute/fixed时)\n如果元素没有已定位的父元素，那么它的位置相对于<html>。\n\n绝对定位与文档流无关，所以它们可以覆盖页面上其他的元素，可以通过z-index属性来控制这些层的对方顺序\n失去文档中位置。会层叠在文本流之上。\n解决方法1：在js中设置父元素高度等于子元素的高度。\n解决方法2：给父元素强行设置高度。（对于宽度导致的类似问题就强行设置宽度）\n\nfixed ；的元素是相对于视口定位的，这意味着即使滚动页面，它也始终位于同一位置\nsticky：的元素根据用户的滚动位置进行定位。\n\nz-index 的默认值为 auto 。auto 。number inherit。\n\nz-index起作用：堆叠上下文只有在postion:relative/absolute/fixed/sticky脱离文档流控制时才生效，static时无效。\n\nz-index不起作用的几种情形\n（1）当前设置z-index元素的父元素position:relative/absolute;\n(2) 当前设置z-index元素为浮动元素。\n\n\n比较两个 DOM 元素显示顺序 ？接下来就来总结一下如何比较两个 DOM 元素的显示顺序呢？\n如果是在相同的层叠上下文，按照层叠水平的规则来显示元素\n后来居上原则\n谁 z-index 大，谁在上的准则\n如果z-index相等。\n顺序：层叠上下文。负index。 block块水平盒子。float浮动盒子。inline&inlineblock水平盒子。 auto或者为0。正的index。\n父子继承问题：如果父元素没有处于堆叠上下文时，即z-index:auto;或者position:static;时，子元素不会继承父元素的优先级。\n当父元素和子元素都处于堆叠上下文时，子元素继承父元素的优先级，故父元素大的就大\n如果是在不同的层叠上下文中，先找到共同的祖先层叠上下文，然后比较共同层叠上下文下这个两个元素所在的局部层叠上下文的层叠水平。\n\n使用准则：\n不犯二准则：对于非浮层元素，避免设置 z-index 值，z-index 值没有任何道理需要超过 2\n对于浮层元素，可以通过 JS 获取 body 下子元素的最大 z-index 值，然后在此基础上加 1 作为浮层元素的 z-index 值\n\n位置摆放：\n一、左和右对齐 -\n1.使用 position\n对齐元素的一种方法是使用 position: absolute;   right: 0px;\n2. 使用 float\n   对齐元素的另一种方法是使用 float 属性；\n   居中对齐：\n   元素内居中文本，请使用 text-align: center;\n   如需居中图像，请将左右外边距设置为 auto\n")])])]),e("h2",{attrs:{id:"part3、小盒子在大盒子飘起来"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part3、小盒子在大盒子飘起来"}},[n._v("#")]),n._v(" Part3、小盒子在大盒子飘起来")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("浮动的值：float：left。right 。none。inherit。\n浮动原理: 块级元素脱离文档流。浮动的框可以向左或向右移动，直到它的外边缘碰到包含框 或 另一个浮动框的边框为止。\n浮动特性：脱标。浮动元素之间互相贴靠。产生”字围“效果。收缩效果(当浮动元素没有设置尺寸,会适应浮动元素内的子元素尺寸)。浮动元素设置margin_top不会发生塌陷现象\n浮动应用：主要应用于多个 块级元素 横向布局.让多个块级标签在一行。等宽的框。导航菜单。(块转行内块也可以实现一行显示,不过存在空白折叠现象)\n浮动影响：浮动只会对文档流一行和后面的盒子产生影响。对文档流的盒子是不会影响的。\n浮动变化：\n    1、内联元素 在浮动时将变为块级元素。\n这是因为浮动时的所有元素都将获得block其display属性（inline-table将获得table）的值，从而使它们成为块级元素。\n2、未指定宽度的块元素将在浮动时自适应其内容。\n通常，如果未指定块元素的宽度，则其宽度为默认值100％。但是，当浮动时，情况就不再如此; 块元素的框将缩小，直到其内容保持可见\n3、浮动的父元素：\n父元素不关心他们的“漂浮”子元素，除了他们不应该离开他们的左边界或右边界。\n通常，未指定高度的块元素会增加其高度以容纳其子元素，但“Float”子元素不是这种情况。如果“浮动”大小增加，其父级将不会相应地增加其高度。\n\n特殊浮动：当带有字的元素碰到浮动时会自动绕开\n\n浮动塌陷：解决没设置高度父盒子因为子盒子浮动而造成的塌陷问题。\n清除浮动:\n1、内墙法：给后面的父盒子设置clear:both属性（缺陷:上面的盒子height还是0 所以margin会失效）\n2、给父盒子添加用overflow:hidden。\n3、使用::after伪元素给盒子添加最后一个子元素 并且给::after设置clear:both(伪元素为行内元素 务必要设置成块元素)\n4、双伪元素清除浮动\n\n浮动遇上定位：\nfloat 可以和 relative 混用： 两个同时起作用\nfloat 和 absolute 不可以混用。绝对或固定定位的元素将不会浮动。float不生效.一旦混用浮动和绝对定位，则绝对定位会使浮动属性失效。\n一个块float和另一个absolute块的z轴位置。absolute 不设置z-index的情况下。absolute 设置z-index = -1的情况下。\n")])])]),e("h2",{attrs:{id:"part4、flex布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part4、flex布局"}},[n._v("#")]),n._v(" Part4、flex布局")]),n._v(" "),e("h3",{attrs:{id:"_1、flex理解"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1、flex理解"}},[n._v("#")]),n._v(" 1、flex理解")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1、为什么要学flex。\n    面试。工作。\n\n2、面试常考那些？工作常用那些？\n    1、flex垂直居中。\n    2、flex实现左固定，右自适应。\n    3、flex实现3栏等宽布局。\n    4、flex实现骰子![img.png](img.png)。\n    5、flex:1什么意思。(概念)\n\n3、Q:为什么要有Flex布局？ \n    A:Flex布局都是弥补之前布局的缺陷。 \n\n4、Q:那之前的布局有哪些缺陷？Flex又是如何解决呢？    \n    A:  margin，padding: 需要计算px。\n        定位原理： 通过计算px进行布局。top,left等。\n        定位问题: 单个元素需要计算px，考虑父元素的关系。多个元素之间关系。\n        浮动原理： 通过脱离标准流进行布局。\n        浮动问题：在于清除浮动。\n        Flex解决：和数学一样引入轴的概念。通过对容器进行主轴、侧轴的 排序，换行，主轴定位和侧轴定位 来达到目的。\n        Flex概念：2009年w3c发布一项技术。目前所有浏览器都支持。为什么是弹性。主轴，侧轴可以伸缩。来到底布局。\n        Grid解决：更厉害。二维布局,将容器划分成了“行”和“列”，产生了一个个的网格。\n\n5、Q:理解flex容器和flex项目。\n    1、父盒子：给display:flex/inline-fiex，称为flex容器。子盒子：这样里面会自动变成flex项目。 子元素的float、clear、vertical-align属性将失效。\n    2、父盒子属性:![img_1.png](img_1.png)\n    属性中重要的是主轴：伸缩项目沿其一次排列的轴被称为主轴。\n    侧轴：垂直于主轴的轴被称为侧轴。默认情况下，所有子元素作为伸缩项目都是沿着主轴水平排列\n    轴是最关键。我们有6个属性。都是对轴的属性。通过轴达到。轴的方向，主轴的对齐方式，\n        main axis主轴  cross axis  交叉轴\n        main size 。cross size。 主轴长度。交叉轴长度。\n        main start 。 main end。\n        cross start 。cross end\n")])])]),e("h3",{attrs:{id:"_2、flex属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2、flex属性"}},[n._v("#")]),n._v(" 2、flex属性")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("6、flex容器属性。\n    学习一下英语：方向：dirtecion。修正：justifty。align对齐。\n    1、flex-dirtection\n        *作用:定义了主轴的方向(正方向或反方向)。\n        *值:\n        - 默认：row。\n        - row: 设置主轴是水平方向 默认\n        - row-reverse: 与 row 的方向相反\n        - column：设置主轴的方向是垂直方向\n        - column-reverse: 与column 方向相反\n    2、flex-wrap: \n        *作用：设置伸缩容器的子元素是单行显示还是多行显示。 \n        *值：\n        -默认：nowrap。\n        -nowrap：单行显示。挤在一起。\n        -wrap：多行显示。分开。\n    3、justify-content:\n        * 作用：主轴的子元素排列方式(头部尾部居中，周围平分，贴边平分).    \n        * 值\n        - 默认值：flex-start\n        - flex-start: 默认从头部开始。\n        - flex-end: 从尾部开始。\n        - center: 主轴居中对齐。(可以垂直，也可以水平，根据主轴来定)\n        - space-around: 平分剩余空间。（剩余空间给margin-left，margin-right）\n        - space-between:  先两边贴边，在平分剩余空间。（重要）\n        - 没有stretch。\n    4、align-items:(子项目不设置宽高)\n        * 作用：侧轴的子元素排列方式。在子项目是单行的时候用。\n        * 值\n        - 默认值:str etch。\n        - str etch: 拉伸 flex 项目以填充容器（默认）(但是不要给元素高度，否则不起作用)\n        - flex-start:  从上倒下。\n        - flex-end: 从下到上。\n        - center: 挤在一起。\n        - baseline 值使 flex 项目基线对齐\n        - 没有space-around,space-between。\n    5、align-content：设置子项侧轴排列方式且子项出现换行的情况(所有子项目宽度的和>父项目宽度，并且设置换行)，单行是没有效果。\n        * 作用：侧轴的子元素排列方式。在子项目是单行的时候用。\n        * 值\n        - 默认值：stretch。\n        - flex-start:  侧轴开头排列。\n        - flex-end: 侧轴尾部排列。\n        - center: 侧轴居中对齐。(可以垂直，也可以水平，根据主轴来定)\n        - space-around: 平分剩余空间。（剩余空间给margin-left，margin-right）\n        - space-between:  先两边贴边，在平分剩余空间。（重要）\n        -  stretch: 拉伸弹性线以占据剩余空间（默认）。（不要给高度。）\n\n7、flex子项属性。\n    1、flex子项目占剩余空间的份数及计算。\n        1、flex\n            1、单值 \n                1、无单位数字：\n                    flex-grow:1=flex(1 1 0%)用于等分布局)\n                    flex-grow:0=flex(0 1 0%)用于等分布局)\n                    元素尺寸不会弹性增大（flex-grow:0）,但是会弹性收缩(flex-shrink:1），\n                    考虑到此时flex-basis属性值是0%，表示基础尺寸是0，因此设置flex:0的元素尺寸表现为最小内容宽度，也就是文字会呈现“一柱擎天”的效果。\n                2、有效宽度px：\n                    flex: 12px = flex(1 1 12px)\n                3、flex:none = flex(0 0 auto)\n                    flex子项没有弹性，此时flex-basis属性值是auto，即基础尺寸由内容决定，\n                    因此设置flex:none的元素最终尺寸通常表现为最大内容宽度。\n                4、flex:auto = flex(1 1 auto)\n                    flex:auto等同于设置flex:1 1 auto，元素尺寸可以弹性增大，也可以弹性减小，在容器尺寸不足时会优先最大化内容尺寸。\n                5、flex: initial = 【默认值】flex( 0 1 auto) \n            2、双值\n                1、无单位数+无单位数：flex-grow,flex-shrink\n                2、无单位数+有效宽度值：flex-grow,flex-shrink.\n            3、3值\n                1、无单位数+无单位数+有效宽度值。flex-basis。\n        2、flex-grow\n            *作用：计算剩余空间。进行平分。\n            *值:\n                -默认值：0\n        3、flex-shrink\n            *作用：会缩小换行。子元素超出的宽度 * flex-shrink的值 * 子元素宽度 / 总值;最大最小尺寸限制>弹性收缩，弹性扩张>基础尺寸\n            *值:\n            -默认值：1\n        4、flex-basis\n            *作用：\n            *值:\n            -默认值：auto\n    2、align-self\n        *作用：自己在侧轴的排列方式。\n        *值：\n        -默认值：auto(该值使该属性直接继承其父元素的行为)\n        -flex-end\n        -flex-start\n        -center\n        -str etch\n    3、order:\n        *作用：子项的排列顺序。越小越靠前。\n        *值：\n        -默认值：0\n")])])]),e("h3",{attrs:{id:"_3、flex实战"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3、flex实战"}},[n._v("#")]),n._v(" 3、flex实战：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("1、垂直居中:(center)\n2、左边固定,右边自适应:(flex:1)。\n3、左边固定,右边固定,中间自适应:(flex:1)。\n4、等高:每一个都是(flex:1)\n5、页面布局：垂直方向中间自适应。\n6、单个筛子：justify-content，align-item 。2个筛子。3,4,5,6个筛子。\n")])])]),e("h2",{attrs:{id:"part5、grid布局"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part5、grid布局"}},[n._v("#")]),n._v(" Part5、Grid布局")]),n._v(" "),e("h2",{attrs:{id:"part6、溢出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part6、溢出"}},[n._v("#")]),n._v(" Part6、溢出")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("溢出定义:属性指定在元素的内容太大而无法放入指定区域时是剪裁内容还是添加滚动条。\ndiv{overflow: hidden}隐藏。\ndiv{overflow:scroll}滚动\ndiv{overflow: auto}滚动条\ndiv{ overflow-x: hidden; overflow-y: scroll; }\ncss中实现单行多行文字截断:\n")])])]),e("h2",{attrs:{id:"part7、bfc原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#part7、bfc原理"}},[n._v("#")]),n._v(" Part7、BFC原理")]),n._v(" "),e("p",[n._v("BFC：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[n._v("页面上的一个隔离的独立容器。一个不会影响到外面的独立封闭空间。\n创建BFC:\n根元素\ndisplay的值是inline-block flex或者inline-flex\nposition的值不是static或者relative\noverflow:hidden\nBFC的特性：\n1内部的Box会在垂直方向上一个接一个的放置\n2垂直方向上的距离由margin决定\n3 bfc的区域不会与float的元素区域重叠\n4 计算bfc的高度时 浮动元素也参与计算\n")])])]),e("p",[n._v("参考：https://juejin.cn/post/6963251091035291656/")])])}),[],!1,null,null,null);e.default=l.exports}}]);