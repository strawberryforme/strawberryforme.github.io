(window.webpackJsonp=window.webpackJsonp||[]).push([[42],{441:function(n,t,e){"use strict";e.r(t);var a=e(2),r=Object(a.a)({},(function(){var n=this,t=n._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("blockquote",[t("p",[n._v("语句和声明: 1、变量声明。2、循环和判断语句。3、函数、类声明 4、对象声明")])]),n._v(" "),t("h2",{attrs:{id:"_1、变量声明-var-let-const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、变量声明-var-let-const"}},[n._v("#")]),n._v(" 1、变量声明 var,let,const")]),n._v(" "),t("h3",{attrs:{id:"var"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[n._v("#")]),n._v(" var")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、声明的是变量。可以重复赋值。\n2、可以重复声明  \n2、var 声明的变量作用域是全局或者整个函数块的。会在全局对象上创建属性。\n3、使用 var 声明的变量将在任何代码执行前被创建，这被称为变量提升。这些变量的初始值为 undefined。\n")])])]),t("h3",{attrs:{id:"let"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#let"}},[n._v("#")]),n._v(" let")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、声明的是变量。可以重复赋值。\n2、不能重复声明。\n2、let是块级作用域。不会在全局对象上创建属性。\n3、let有提升功能，但是会出现“暂时性死区”。原因预编译的原因。\n")])])]),t("h3",{attrs:{id:"const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#const"}},[n._v("#")]),n._v(" const")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、声明的是常量（const 是不可以的修改的）（const 只能保证栈内存中的地址不变）。但通常情况下全部用大写字母。\n2、const不允许只声明不赋值，一旦声明就必须赋值。不能重复声明\n3、作用域 const是块级作用域。\n4、const有提升功能，但是会出现“暂时性死区”\n")])])]),t("h3",{attrs:{id:"_2、循环和判断语句"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、循环和判断语句"}},[n._v("#")]),n._v(" 2、循环和判断语句")]),n._v(" "),t("p",[n._v("6循环： for for…in for…in for await…of do…while while 2个条件：if…else  switch\nfor…in")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、for in适用于检查对象属性的key\n2、适用于检查对象 key，不应该用于迭代一个关注索引顺序的 Array。\n3、一个对象的 除Symbol以外的可枚举属性，包括继承的可枚举属性。不想要继承。if (iterable.hasOwnProperty(i))\n")])])]),t("p",[n._v("for…in")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、for…of注重的是值value。可迭代对象。上创建一个迭代循环。\n2、迭代Array。迭代string。迭代 TypedArray。迭代Map。 迭代 arguments 对象。迭代 DOM 集合。迭代生成器\n")])])]),t("h2",{attrs:{id:"_3、函数、类声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、函数、类声明"}},[n._v("#")]),n._v(" 3、函数、类声明")]),n._v(" "),t("p",[n._v("2个：Function void\n2个异步async_function await\n2个迭代器yield yield*\n2个继承class super\n1个this")]),n._v(" "),t("p",[n._v("4个：function async function* class\n4个：return continue break label\n4个：try…catch throw debugger empty\n2个：export import\nArrow function expressions\nDefault parameters Rest parameters The arguments object\nMethod definitions\nOBJ:getter,setter")]),n._v(" "),t("p",[n._v("Class:constructor extends Private class features Public class fields static\n剩余参数语法允许我们将一个不定数量的参数表示为一个数组。")]),n._v(" "),t("h3",{attrs:{id:"_4、对象-11"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4、对象-11"}},[n._v("#")]),n._v(" 4、对象 （11）")]),n._v(" "),t("h3",{attrs:{id:"增-删-object-init-new-delete-destruemest"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#增-删-object-init-new-delete-destruemest"}},[n._v("#")]),n._v(" 增，删：Object init,new,delete,destruemest")]),n._v(" "),t("p",[n._v("new:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("new原理:\n    obj的__proto__挂载在Function.prototype。1、创造一个空{}。2、{}.proto ->Function.prototype。3.{}执行函数。4.返回obj\nnew返回：\n    默认返回 this 对象。如果手动指定返回对象，则 new 出来的实例指向的是 return 的对象，而不是 this。\n")])])]),t("p",[n._v("属性访问：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("Property accessors。. []。\n")])])]),t("p",[n._v("解构赋值：")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v('解决问题：let repeat = options.repeat, save = options.save;\n语法形式：语法形式是在一个赋值操作左边放置一个对象字面量\n注意：一定要用一对小括号包裹解构赋值语句，javascript引擎将一对开放的花括号视为一个代码块，而语法规定，代码块不能出现在赋值语句的左侧，添加小括号后可以将块语句转化为一个表达式，从而实现整个解构赋值的过程。\n1、解构数组\n    变量声明并赋值时的解构。 var [one, two, three] =  ["one", "two", "three"];\n    变量先声明后赋值时的解构。 var a, b; [a, b] = [1, 2];\n    交换变量：[a, b] = [b, a];\n    结构函数返回一个数组：[a, b] = function f() {return [1, 2];}\n    省略中间值：var [a, , b] = [1,2,3];\n    剩余数组：var [a=10, ...b] = [1, 2, 3];(剩余元素必须是数组的最后一个元素。)\n2、解构对象\n    基本赋值:var {p, q} = {p: 42, q: true};\n    无声明赋值：({a, b} = {a: 1, b: 2}); {a, b} = {a: 1, b: 2} 不是有效的独立语法，因为左边的 {a, b} 被认为是一个块而不是对象字面量。\n    给新的变量名赋值：var {p: foo, q: bar} = {p: 42, q: true}; //先把a解构赋值给a。然后吧a重命名为aa嘛。\n    默认值：var {a = 10, b = 5} = {a: 3};默认值可以引用解构赋值的其他变量，但该变量必须已经声明。let [x = y, y = 1] = [];// ReferenceError\n    给新的变量命名并提供默认值 var {a:aa = 10, b:bb = 5} = {a: 3}; const { a: aa, b } = { a: 3, b: 4 };//a报错。\n    对象属性计算名和解构 let { [key]: foo } = { z: "bar" };\n    剩余对象：let {a, b, ...rest} = {a: 10, b: 20, c: 30, d: 40}\n    解构对象时会查找原型链（如果属性不在对象自身，将从原型链中查找）const {self, prot} = obj;\n    解构嵌套对象和数组： let {loc:{start}} = node;let {loc:{start:localStart}} = node;\n    混合解构：let {loc:{start},range:[startIndex]} = node;\n3、函数参数默认值\n    函数参数默认值\n    从作为函数实参的对象中提取数据\n4、 迭代和解构\n        For of\n5、模块化\n     解构赋值使得输入语句非常清晰。const { SourceMapConsumer, SourceNode } = require("source-map");\n')])])]),t("p",[n._v("null:")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1、JavaScript 基本类型 之一。\n2、在布尔运算中被认为是false。\n3、null值 null 是一个字面量，不像 undefined，它不是全局对象的一个属性。\n")])])]),t("h3",{attrs:{id:"查-in-instanceof-typeof"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#查-in-instanceof-typeof"}},[n._v("#")]),n._v(" 查：in,instanceof,typeof,")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("展开语法：\n    函数调用：\n        myFunction.apply(null, args);//之前是使用apply传入数组\n        myFunction(-1, ...args, 2, ...[3]); 将数组表达式或者 string 在语法层面展开；\n        new Date(...dateFields);\n        \n    字面量数组构造或字符串：\n        只能组合使用 push, splice, concat 等方法，来将已有数组元素变成新数组的一部分。\n        var lyrics = ['head', ...parts, 'and', 'toes'];\n        var arr2 = [...arr]; arr2 和arr不受影响\n        var arr1 = [...arr2, ...arr1];\n        展开语法和 Object.assign() 行为一致，执行的都是浅拷贝\n        只能用于可迭代对象：var array = [...obj];//是错误的\n\n    构造字面量对象：\n        let objClone = { ...obj };还可以在构造字面量对象时，将对象表达式按 key-value 的方式展开。\n        Object.assign() 函数会触发 setters，而展开语法则不会。\n        不能替换或者模拟 Object.assign() 函数：而是先将多个解构变为剩余参数 (rest parameter), 然后再将剩余参数展开为字面量对象。\n\n可选链：\n    原理：\n        先隐式地检查并确定obj.first 既不是 null 也不是 undefined。则找first.second的值。\n        如果obj.first 是 null 或者 undefined，表达式将会短路计算直接返回undefined。\n        let a = 1 && 2 //a=2   let a = 1 && 2 && 3 //a=3\n        let a = obj.first && obj.first?.second;//左边为真，返回右边\n        let nestedProp = obj.first?.second; // obj.first存在。返回second。否则返回null。\n    可选链与函数调用\n        let result = someInterface.customMethod?.();\n        obj.func?.(args) obj?.b?.(); //使用方法\n    可选链和表达式\n        obj.val?.prop  o?.a?.b?.c?.d;\n        let nestedProp = obj?.['prop' + 'Name'];\n    可选链访问数组元素：\n        obj.val?.[expr]  obj?.a?.[0]; // 访问数组\n    可选链不能用于赋值\n        object?.property = 1;\n    短路计算：\n        let prop = potentiallyNullObj?.[x++]; 如果左操作数是 null 或 undefined，表达式将不会被计算\n\nin:\n    语法：\n        左边是属性，右边是对象。prop in object。返回true或者false。\n    定义：\n        属性在指定的对象或其原型链中，则 in 运算符返回 true 。否则返回false。\n    应用：\n        数组：index in array  //(必须使用索引号，而不是数组元素的值)\n        对象。\"make\" in mycar \n        undefined:\"undefined\" in mycar;  // 返回 true\n        \"toString\" in {}; //原型链的属性返回true\n    hasOwnProperty\n        1、该方法仅用于判断自身对象，不会查找原型链。\n        2、对象的私有属性（不仅要有这个属性，而且必须还是私有的才可以）\n\ninstanceof:\n    1、语法：\n        左边是一个对象，右边是对象的构造函数。返回true或者false。\n    2、实现\n        实例的原型__proto__ 和 构造函数的 prototype 。\n        检测构造函数的 prototype 属性是否出现在某个实例对象的原型链上 。 \n        obj.__proto === Function.prototype\n        obj.__proto !== function.prototype obj.__proto__.__proto__\ntypeof:\n    1、语法：\n        右边是一个对象。返回一个字符串，表示操作数的类型。\n    2、判断基本数据类型时\n        除了 null 的输出结果为'object' 其它类型都能正确判断\n    3、typeof 判断引用数据类型时，\n        除了判断函数会输出'function' 其它都输出'object'")])])])])}),[],!1,null,null,null);t.default=r.exports}}]);